### 1.使用消息队列带来的好处
* 流量削峰
* 异步处理
* 服务之间的解耦

### 2.使用消息队带来的问题
* 增加系统的复杂程度
* 消息积压会带来延时的问题
* 增加了系统的复杂度

### 3.市面上有哪些mq
#### 第一梯队
* RabbitMq
* RocketMq
* Kafka
#### 第二梯队
* ActiveMq
* Pulsar
* ZeroMq

### 3.队列和主题的区别
* 队列FIFO,若存在多个消费者，每个消费者只能消费部分消息
* 主题也是队列，主题下可以包含一个或多个队列，采用发布订阅的方式，每个消费组都能消费主题下的所有消息。
  1.解决了队列的一条消息不能被多次消费的问题
  2.解决了队列的并发生产和并发消费的问题
  
### 4.消息事务
* RabbitMq支持
* RocketMq支持<br>
  1.producer发送半消息到broker（半消息是完整的消息，只是这时候对consumer是不可见的）<br>
  2.broker发送确认半消息到producer<br>
  3.producer执行本地事务<br>
  4.producer根据执行事务的成功或失败，发送commit或rollback给broker<br>
  5.若broker没有收到producer上面的4步骤的消息，执行事务的反查机制，随机调用一个producer检查事务执行的状态<br>
  6.然后根据事务的发查机制，来判断消息是提交还是回滚<br>
* Kafka支持，和RocketMQ类似，只是kafka在上面第4步骤失败，直接抛出异常，让客户端自己处理，没有反查机制

### 5.如何保证消息不丢失？
* producer和consumer采用的方式一样，采用send和ack和重试的机制
* broker采用刷盘，分布式系统保证消息复制到半数以上的机器，再给producer回复ack

### 6.消息重复了怎么办？
* 例如上面5，因为网络原因，都会导致producer和consumer未收到broker发送的ack，因为重试机制，就会导致同一条消息重发，
或者同一条消息重复消费，这时候我们需要保证消费端的幂等性就能解决该问题

### 7.怎样实现消费的幂等性呢？
* 对于插入场景，数据库的唯一索引，加上事务的方式
* 对于更新场景，可以采用版本号的方式，结合事务
* 消息的全局唯一id结合分布式锁，分布式锁实现可以采用（数据库for update，redis setnx，zookeeper）

### 8.消息积压了怎么办？
* 最快的，最简单的方式增加消费实例
* 最治标治本的方式，分析消费端，消费速率降低的问题
